const { test, expect } = require('@playwright/test');

test.describe('Select Option Tests', () => {
  test('Select dropdown with comprehensive assertions', async ({ page }) => {
    // Increase test timeout to handle slow application
    test.setTimeout(60000); // 60 seconds instead of default 30
    console.log('üöÄ Starting Select Option test with comprehensive assertions...');
    
    // Capture console errors and network errors
    const consoleErrors = [];
    const networkErrors = [];
    
    // Listen for console errors
    page.on('console', msg => {
      if (msg.type() === 'error') {
        consoleErrors.push({
          type: 'console',
          message: msg.text(),
          location: msg.location(),
          timestamp: new Date().toISOString()
        });
        console.log('‚ùå Console Error:', msg.text());
      }
    });
    
    // Listen for network errors
    page.on('response', response => {
      if (!response.ok()) {
        networkErrors.push({
          type: 'network',
          url: response.url(),
          status: response.status(),
          statusText: response.statusText(),
          timestamp: new Date().toISOString()
        });
        console.log(`‚ùå Network Error: ${response.status()} ${response.statusText()} - ${response.url()}`);
      }
    });
    
    // Listen for failed requests
    page.on('requestfailed', request => {
      networkErrors.push({
        type: 'request_failed',
        url: request.url(),
        failure: request.failure()?.errorText || 'Unknown error',
        timestamp: new Date().toISOString()
      });
      console.log(`‚ùå Request Failed: ${request.url()} - ${request.failure()?.errorText}`);
    });
    
    // Function to save error report (can be called anytime)
    const saveErrorReport = async (testStatus = 'unknown') => {
      if (consoleErrors.length > 0 || networkErrors.length > 0) {
        const fs = require('fs');
        const errorReport = {
          testName: 'Add Customer Test',
          testStatus: testStatus,
          timestamp: new Date().toISOString(),
          consoleErrors,
          networkErrors,
          totalErrors: consoleErrors.length + networkErrors.length
        };
        
        const reportPath = 'error-report.json';
        fs.writeFileSync(reportPath, JSON.stringify(errorReport, null, 2));
        console.log(`\nüìÑ Error report saved to: ${reportPath} (Test Status: ${testStatus})`);
        console.log('üìß Share this file with your development team for debugging');
        
        // Attach the error report to the HTML report
        await test.info().attach('error-report.json', {
          path: reportPath,
          contentType: 'application/json'
        });
        console.log('üìé Error report attached to HTML report');
        
        // Also create a human-readable summary
        const summaryPath = 'error-summary.md';
        const summary = `# Error Summary for Add Customer Test

**Test Status:** ${testStatus}  
**Timestamp:** ${new Date().toISOString()}  
**Total Errors:** ${consoleErrors.length + networkErrors.length}

## Console Errors (${consoleErrors.length})
${consoleErrors.map((error, index) => `
### ${index + 1}. ${error.message.split('\n')[0]}
- **Location:** ${error.location.url}:${error.location.lineNumber}:${error.location.columnNumber}
- **Time:** ${error.timestamp}
`).join('')}

## Network Errors (${networkErrors.length})
${networkErrors.map((error, index) => `
### ${index + 1}. ${error.type.toUpperCase()}
- **URL:** ${error.url}
- **Status:** ${error.status} ${error.statusText}
- **Time:** ${error.timestamp}
`).join('')}

---
*This report was automatically generated by Playwright test automation.*
`;
        
        fs.writeFileSync(summaryPath, summary);
        await test.info().attach('error-summary.md', {
          path: summaryPath,
          contentType: 'text/markdown'
        });
        console.log('üìé Error summary attached to HTML report');
      }
    };
    
    // Wrap the entire test in try-catch to capture errors even on failure
    try {
    
    // Step 1: Login to the application
    console.log('üì± Navigating to ezSCM website...');
    await page.goto('http://192.168.0.100:3000/');
    console.log('‚úÖ Page loaded successfully');
    
    console.log('üìß Filling email field...');
    await page.getByRole('textbox', { name: 'Email or Phone number' }).click();
    await page.getByRole('textbox', { name: 'Email or Phone number' }).fill('rollinivi4+test@gmail.com');
    console.log('‚úÖ Email filled: rollinivi4+test@gmail.com');
    

    console.log('üîí Filling password field...');
    await page.getByRole('textbox', { name: '********' }).click();
    await page.getByRole('textbox', { name: '********' }).fill('User@123');
    console.log('‚úÖ Password filled');
    
    
    console.log('‚òëÔ∏è Checking "Keep me logged in" checkbox...');
    await page.getByText('Keep me logged in').click();
    console.log('‚úÖ Checkbox checked');
    
    console.log('üñ±Ô∏è Clicking login button...');
    await page.getByRole('button', { name: 'Log in' }).click();
    console.log('‚úÖ Login button clicked');
    
    // Wait for login to complete
    console.log('‚è≥ Waiting for login to complete...');
    
    // Wait for dashboard to load - try multiple selectors
    try {
      await page.waitForSelector('text=Sales Orders', { timeout: 10000 });
      console.log('‚úÖ Dashboard loaded - Sales Orders found');
    } catch (error) {
      console.log('‚ö†Ô∏è Sales Orders not found, trying alternative selectors...');
      try {
        await page.waitForSelector('text=Sales', { timeout: 5000 });
        console.log('‚úÖ Dashboard loaded - Sales found');
      } catch (error2) {
        console.log('‚ö†Ô∏è Sales not found, trying navigation menu...');
        await page.waitForSelector('nav, .sidebar, .menu', { timeout: 5000 });
        console.log('‚úÖ Dashboard loaded - Navigation found');
      }
    }
    
    // Take screenshot after login
    console.log('üì∏ Taking screenshot after login...');
    try {
      await page.screenshot({ path: 'screenshot-login.png' });
      console.log('‚úÖ Screenshot saved as screenshot-login.png');
    } catch (error) {
      console.log('‚ö†Ô∏è Screenshot failed, continuing...');
    }
    
    // Give a short stabilization time - use waitForLoadState instead of waitForTimeout
    console.log('‚è≥ Waiting for dashboard to fully stabilize...');
    try {
      await page.waitForLoadState('networkidle', { timeout: 5000 });
      console.log('‚úÖ Dashboard stabilized (network idle)');
    } catch (error) {
      console.log('‚ö†Ô∏è Network idle timeout, continuing...');
      // Fallback to a very short timeout
      await page.waitForTimeout(500);
      console.log('‚úÖ Dashboard stabilized (fallback)');
    }
    
    // Step 2: Navigate to Sales Orders
    console.log('üîç Looking for Sales Orders menu...');
    
    // Try multiple selectors for Sales Orders
    const salesOrderSelectors = [
      'text=Sales Orders',
      'text=Sales',
      'a[href*="sales"]',
      'button:has-text("Sales")',
      '.menu-item:has-text("Sales")'
    ];
    
    let salesOrderFound = false;
    for (const selector of salesOrderSelectors) {
      try {
        const element = page.locator(selector);
        if (await element.count() > 0) {
          await element.first().click();
          console.log(`‚úÖ Sales Orders clicked using selector: ${selector}`);
          salesOrderFound = true;
          break;
        }
      } catch (error) {
        console.log(`‚ö†Ô∏è Selector ${selector} not found`);
      }
    }
    
    if (!salesOrderFound) {
      console.log('‚ö†Ô∏è Could not find Sales Orders menu, continuing...');
    }
    
    // Wait for Sales Orders page to load
    try {
      await page.waitForSelector('text=Create New Sales Order', { timeout: 10000 });
      console.log('‚úÖ Sales Orders page loaded');
    } catch (error) {
      console.log('‚ö†Ô∏è Create New Sales Order not found, trying alternative...');
      await page.waitForSelector('select[id*="shipmentStatus"]', { timeout: 5000 });
      console.log('‚úÖ Dropdown found on page');
    }
    
    console.log('üì∏ Taking screenshot of Sales Orders page...');
    try {
      await page.screenshot({ path: 'screenshot-salesOrders.png' });
      console.log('‚úÖ Screenshot saved as screenshot-salesOrders.png');
    } catch (error) {
      console.log('‚ö†Ô∏è Screenshot failed, continuing...');
    }
    // ========================================
    // DROPDOWN SELECTION - EASY METHOD
    // ========================================
    console.log('üìã Selecting dropdown option...');
    
    // EASY METHOD: Select option by label (most readable)
    await page.locator('select[id="salesOrder_salesOrders_shipmentStatusSelect"]').selectOption({label: 'New'});
    console.log('‚úÖ Option "New" selected successfully');
    
    // Wait for selection to take effect
    await page.waitForTimeout(2000);
    
    // ========================================
    // OTHER METHODS (COMMENTED FOR REFERENCE)
    // ========================================
    
    // Method 1: Direct selectOption with value
    // await page.selectOption('select[id="salesOrder_salesOrders_shipmentStatusSelect"]', 'New');
    
    // Method 2: Select by value using locator
    // await page.locator('select[id="salesOrder_salesOrders_shipmentStatusSelect"]').selectOption({value: 'new'});
    
    // Method 3: Select by index (0-based)
    // await page.locator('select[id="salesOrder_salesOrders_shipmentStatusSelect"]').selectOption({index: 1});
    
    // Method 4: Using getByRole (best for accessibility)
    // await page.getByRole('combobox', { name: /shipment status/i }).selectOption('New');
    
    // Method 5: Select multiple options (if dropdown supports it)
    // await page.locator('select[id="salesOrder_salesOrders_shipmentStatusSelect"]').selectOption(['New', 'Pending']);
    
    // ========================================
    // COMPREHENSIVE ASSERTIONS
    // ========================================
    
    console.log('üîç Running comprehensive assertions...');
    
    // 1. Verify the dropdown element exists and is visible
    const dropdown = page.locator('select[id="salesOrder_salesOrders_shipmentStatusSelect"]');
    await expect(dropdown).toBeVisible();
    console.log('‚úÖ Dropdown is visible');
    
    // 2. Verify the dropdown is enabled (not disabled)
    await expect(dropdown).toBeEnabled();
    console.log('‚úÖ Dropdown is enabled');
    
    // 3. Verify the selected value matches expected value
    const selectedValue = await dropdown.inputValue();
    console.log(`üìã Selected value: ${selectedValue}`);
    await expect(dropdown).toHaveValue('New');
    console.log('‚úÖ Selected value assertion passed');
    
    // 4. Verify the selected option text is correct
    const selectedOption = dropdown.locator('option:checked');
    await expect(selectedOption).toHaveText('New');
    console.log('‚úÖ Selected option text assertion passed');
    
    // 5. Verify the dropdown has the correct number of options
    const allOptions = dropdown.locator('option');
    const optionCount = await allOptions.count();
    console.log(`üìä Total options available: ${optionCount}`);
    expect(optionCount).toBeGreaterThan(0);
    console.log('‚úÖ Dropdown has options available');
    
    // 6. Verify specific options exist in the dropdown
    const expectedOptions = ['New', 'Pending', 'Shipped', 'Delivered']; // Adjust based on your actual options
    for (const optionText of expectedOptions) {
      const optionExists = await dropdown.locator(`option:has-text("${optionText}")`).count() > 0;
      if (optionExists) {
        console.log(`‚úÖ Option "${optionText}" exists in dropdown`);
      } else {
        console.log(`‚ö†Ô∏è Option "${optionText}" not found in dropdown`);
      }
    }
    
    // 7. Verify the dropdown is not in a loading state
    await expect(dropdown).not.toHaveAttribute('disabled');
    console.log('‚úÖ Dropdown is not disabled');
    
    // 8. Verify no error messages are displayed after selection
    const errorMessages = page.locator('.error, .alert-danger, [class*="error"]');
    const errorCount = await errorMessages.count();
    if (errorCount === 0) {
      console.log('‚úÖ No error messages displayed after selection');
    } else {
      console.log(`‚ö†Ô∏è ${errorCount} error message(s) found after selection`);
    }
    
    // 9. Verify the page URL hasn't changed unexpectedly
    const currentUrl = page.url();
    expect(currentUrl).toContain('sales'); // Adjust based on your expected URL pattern
    console.log('‚úÖ Page URL is correct after selection');
    
    // 10. Verify the selection persists after a short wait
    await page.waitForTimeout(1000);
    const persistedValue = await dropdown.inputValue();
    await expect(dropdown).toHaveValue('New');
    console.log('‚úÖ Selection persists after wait');
    
    // 11. Test selecting a different option to verify dropdown functionality
    console.log('üîÑ Testing selection of different option...');
    await dropdown.selectOption({ label: 'Pending' });
    await expect(dropdown).toHaveValue('Pending');
    console.log('‚úÖ Successfully selected "Pending" option');
    
    // 12. Return to original selection
    await dropdown.selectOption({ label: 'New' });
    await expect(dropdown).toHaveValue('New');
    console.log('‚úÖ Returned to "New" selection');
    
    // 13. Verify dropdown accessibility attributes
    const ariaLabel = await dropdown.getAttribute('aria-label');
    const ariaLabelledBy = await dropdown.getAttribute('aria-labelledby');
    if (ariaLabel || ariaLabelledBy) {
      console.log('‚úÖ Dropdown has accessibility attributes');
    } else {
      console.log('‚ö†Ô∏è Dropdown missing accessibility attributes');
    }
    
    // 14. Verify the dropdown has proper focus behavior
    await dropdown.focus();
    await expect(dropdown).toBeFocused();
    console.log('‚úÖ Dropdown can receive focus');
    
    // 15. Final comprehensive assertion
    await expect(dropdown).toHaveValue('New');
    await expect(selectedOption).toHaveText('New');
    await expect(dropdown).toBeVisible();
    await expect(dropdown).toBeEnabled();
    console.log('‚úÖ All final assertions passed');
    
    console.log('üéâ All assertions completed successfully!');
    
    // ========================================
    // ERROR HANDLING AND EDGE CASE ASSERTIONS
    // ========================================
    
    console.log('üß™ Testing error handling and edge cases...');
    
    // 16. Test invalid option selection (should handle gracefully)
    try {
      await dropdown.selectOption({ label: 'InvalidOption' });
      console.log('‚ö†Ô∏è Invalid option selection did not throw error');
    } catch (error) {
      console.log('‚úÖ Invalid option selection properly handled');
    }
    
    // 17. Verify dropdown state after invalid selection attempt
    await expect(dropdown).toHaveValue('New'); // Should still be 'New'
    console.log('‚úÖ Dropdown value unchanged after invalid selection');
    
    // 18. Test dropdown interaction with keyboard
    await dropdown.focus();
    await page.keyboard.press('ArrowDown');
    await page.keyboard.press('Enter');
    console.log('‚úÖ Keyboard navigation works');
    
    // 19. Verify dropdown works with different selection methods
    console.log('üîÑ Testing different selection methods...');
    
    // Test by value
    await dropdown.selectOption({ value: 'new' });
    await expect(dropdown).toHaveValue('new');
    console.log('‚úÖ Selection by value works');
    
    // Test by index
    await dropdown.selectOption({ index: 0 });
    console.log('‚úÖ Selection by index works');
    
    // 20. Verify dropdown behavior with rapid selections
    console.log('‚ö° Testing rapid selection changes...');
    const rapidSelections = ['New', 'Pending', 'New'];
    for (const option of rapidSelections) {
      await dropdown.selectOption({ label: option });
      await expect(dropdown).toHaveValue(option);
    }
    console.log('‚úÖ Rapid selection changes work correctly');
    
    // 21. Final state verification
    await expect(dropdown).toHaveValue('New');
    await expect(dropdown).toBeVisible();
    await expect(dropdown).toBeEnabled();
    console.log('‚úÖ Final state verification passed');
    
    // 22. Performance assertion - selection should be fast
    const startTime = Date.now();
    await dropdown.selectOption({ label: 'Pending' });
    const endTime = Date.now();
    const selectionTime = endTime - startTime;
    console.log(`‚è±Ô∏è Selection time: ${selectionTime}ms`);
    expect(selectionTime).toBeLessThan(5000); // Should complete within 5 seconds
    console.log('‚úÖ Selection performance is acceptable');
    
    // 23. Verify no memory leaks or console errors during assertions
    const finalConsoleErrors = consoleErrors.length;
    const finalNetworkErrors = networkErrors.length;
    console.log(`üìä Final error counts - Console: ${finalConsoleErrors}, Network: ${finalNetworkErrors}`);
    
    // 24. Take final screenshot for verification
    console.log('üì∏ Taking final verification screenshot...');
    try {
      await page.screenshot({ path: 'screenshot-final-verification.png' });
      console.log('‚úÖ Final screenshot saved');
    } catch (error) {
      console.log('‚ö†Ô∏è Final screenshot failed, continuing...');
    }
    
    console.log('üèÜ All error handling and edge case tests completed!');
    
    } catch (testError) {
      // Test failed - but we still want to capture and report errors
      console.log('\n‚ùå TEST FAILED - but capturing errors for debugging...');
      console.log(`‚ùå Test Error: ${testError.message}`);
      
      // Save error report even on test failure
      await saveErrorReport('failed');
      
      // Re-throw the error so the test is marked as failed
      throw testError;
    }
  });
});

